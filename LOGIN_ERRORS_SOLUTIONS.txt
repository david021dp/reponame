================================================================================
LOGIN ERRORS AND SOLUTIONS - TROUBLESHOOTING GUIDE
================================================================================

This document outlines all the errors encountered during the login implementation
and how they were resolved.

================================================================================
ERROR #1: Build Error - "next/headers" in Client Component
================================================================================

SYMPTOM:
- Build failed with error: "You're importing a component that needs 'next/headers'"
- Error occurred in: lib/supabase/server.ts
- Error traced through: lib/auth/helpers.ts -> app/login/page.tsx

ROOT CAUSE:
The login page was a client component ('use client'), but it was importing
helper functions that used server-only code (next/headers from lib/supabase/server.ts).
This created a conflict because client components cannot use server-only APIs.

SOLUTION:
Split the auth helpers into two separate files:

1. Created lib/auth/helpers.ts (CLIENT-SIDE ONLY)
   - Contains: signIn(), signOut(), signUp()
   - Uses: lib/supabase/client.ts
   - For: Client components

2. Created lib/auth/server-helpers.ts (SERVER-SIDE ONLY)
   - Contains: getCurrentUser(), getUserRole()
   - Uses: lib/supabase/server.ts
   - For: Server components

3. Updated all imports:
   - Client components (login page) → import from lib/auth/helpers.ts
   - Server components (dashboard, schedule, etc.) → import from lib/auth/server-helpers.ts

FILES MODIFIED:
- Created: lib/auth/server-helpers.ts
- Modified: lib/auth/helpers.ts (removed server functions)
- Modified: app/admin/dashboard/page.tsx (updated import)
- Modified: app/client/schedule/page.tsx (updated import)
- Modified: app/client/appointments/page.tsx (updated import)
- Modified: app/admin/register/page.tsx (updated import)

RESULT: Build successful ✓

================================================================================
ERROR #2: Login Success But Infinite Redirect Loop
================================================================================

SYMPTOM:
- User could enter credentials
- Page would load for a second
- Redirected back to login page
- No error messages shown
- Console showed successful sign-in

ROOT CAUSE:
After successful authentication, the middleware was trying to fetch the user's
role from the users table, but the query was failing silently due to RLS policy
issues. Without role data, the redirect logic couldn't determine where to send
the user, causing a loop.

SOLUTION:
Added better error handling and role checking in the login flow:

1. Modified app/login/page.tsx to:
   - Fetch user role immediately after sign-in
   - Log all steps to console for debugging
   - Show specific error messages
   - Use window.location.href for hard redirect

2. Added console logging:
   - "User signed in: [user_id]"
   - "User data: [role data]"
   - "Role error: [error message]"
   - "Redirecting to: [destination]"

This revealed the real issue (see Error #3).

FILES MODIFIED:
- app/login/page.tsx (added role checking and logging)

================================================================================
ERROR #3: Supabase RLS Policy Infinite Recursion Error
================================================================================

SYMPTOM:
- Browser console showed: "infinite recursion detected in policy for relation 'users'"
- HTTP 500 error when querying users table
- Login flow broke at role checking step

ROOT CAUSE:
The RLS policy "Admins can read all users" was checking if a user is an admin
by querying the users table, which triggered the same policy again, creating
an infinite loop:

PROBLEMATIC POLICY:
CREATE POLICY "Admins can read all users" ON users
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM users  <-- This queries the same table!
      WHERE id = auth.uid() AND role = 'admin'
    )
  );

This is a classic circular dependency in RLS policies.

SOLUTION:
Replaced the problematic policies with simpler, non-recursive ones:

1. DROP the problematic policies:
   DROP POLICY "Admins can read all users" ON users;
   DROP POLICY "Users can read own data" ON users;

2. Created new policies:
   a) "Users can read own data" - Simple self-check
      USING (auth.uid() = id)
   
   b) "Authenticated users can read all users" - No recursion
      USING (auth.role() = 'authenticated')

The key change: Using auth.role() (built-in Supabase function) instead of
querying the users table to check the role.

SUPABASE SQL EXECUTED:
DROP POLICY IF EXISTS "Admins can read all users" ON users;
DROP POLICY IF EXISTS "Users can read own data" ON users;

CREATE POLICY "Users can read own data" ON users
  FOR SELECT
  USING (auth.uid() = id);

CREATE POLICY "Authenticated users can read all users" ON users
  FOR SELECT
  USING (auth.role() = 'authenticated');

FILES MODIFIED:
- Applied migration via Supabase MCP tools

RESULT: Users table queries now work ✓

================================================================================
ERROR #4: UUID Format Error in Users Table
================================================================================

SYMPTOM:
- Error: "invalid input syntax for type uuid: '1'"
- Occurred when trying to insert user into users table
- Error message: "LINE 3: '1'"

ROOT CAUSE:
User tried to insert data into users table with id='1', but the id column
expects a valid UUID format (e.g., 'a1b2c3d4-e5f6-7890-abcd-ef1234567890'),
not a simple integer.

The users table has a foreign key constraint:
id UUID PRIMARY KEY REFERENCES auth.users(id)

This means the id must match an existing UUID from the auth.users table.

SOLUTION:
Correct workflow for creating admin user:

1. Create user in Supabase Auth FIRST (via dashboard):
   - Go to: Authentication → Users
   - Click "Add User"
   - Enter email and password
   - Check "Auto Confirm User"
   - Copy the generated UUID

2. Insert into users table using the real UUID:
   INSERT INTO users (id, email, role, first_name, last_name, phone)
   VALUES (
     'fa5e4c98-ff7d-4ceb-83b9-f7987a78a267',  -- Real UUID from auth.users
     'davidheh15@gmail.com',
     'admin',
     'david',
     'papic',
     '555-0000'
   );

KEY LESSON: Always create auth user first, then use that UUID for users table.

================================================================================
ERROR #5: Email Mismatch Between Tables
================================================================================

SYMPTOM:
- User could sign in (authentication worked)
- But was redirected back to login (authorization failed)
- No visible error to user

ROOT CAUSE:
Email mismatch between auth.users and users tables:
- auth.users: davidheh15@gmail.com
- users: davidheh15@email.com  (typo: @email instead of @gmail)

The middleware checks: "SELECT role FROM users WHERE id = auth.uid()"
This worked, but the login page was also checking email matches.

SOLUTION:
Updated the users table to match the auth.users email:

UPDATE users 
SET email = 'davidheh15@gmail.com' 
WHERE id = 'fa5e4c98-ff7d-4ceb-83b9-f7987a78a267';

VERIFICATION QUERY:
SELECT 
  u.id,
  u.email,
  u.role,
  au.email as auth_email,
  au.email_confirmed_at
FROM users u
LEFT JOIN auth.users au ON u.id = au.id
WHERE u.email = 'davidheh15@gmail.com';

RESULT: Login successful, proper redirect to admin dashboard ✓

================================================================================
SUMMARY OF ALL FIXES
================================================================================

1. ✓ Split auth helpers into client-side and server-side files
2. ✓ Fixed RLS policy infinite recursion by using auth.role()
3. ✓ Created admin user with proper UUID from auth.users
4. ✓ Fixed email mismatch between auth.users and users tables
5. ✓ Added proper error handling and console logging in login flow

================================================================================
FINAL WORKING FLOW
================================================================================

Login Process:
1. User enters email and password
2. signIn() authenticates with Supabase Auth
3. Query users table for role (using fixed RLS policy)
4. Redirect based on role:
   - admin → /admin/dashboard
   - client → /client/schedule
5. Middleware validates session on protected routes

Admin Creation Process:
1. Create user in Supabase Auth dashboard
2. Copy the generated UUID
3. Insert into users table with that UUID
4. Ensure emails match exactly in both tables
5. Admin can now log in

================================================================================
COMMON PITFALLS TO AVOID
================================================================================

❌ DON'T: Mix server and client imports in same file
✓ DO: Separate client and server utilities

❌ DON'T: Create recursive RLS policies that query their own table
✓ DO: Use built-in auth functions (auth.uid(), auth.role())

❌ DON'T: Manually create UUIDs or use simple IDs like '1'
✓ DO: Always use UUIDs generated by Supabase Auth

❌ DON'T: Assume emails match between auth.users and users tables
✓ DO: Verify email consistency with JOIN query

❌ DON'T: Skip error handling in authentication flow
✓ DO: Add console.log and proper error states

================================================================================
DEBUGGING CHECKLIST FOR FUTURE LOGIN ISSUES
================================================================================

If login fails, check:

1. Browser Console
   - Are there any red errors?
   - Do you see "User signed in" log?
   - Do you see "User data" with role?
   - Any Supabase errors (look for .supabase.co URLs)?

2. Supabase Dashboard → Authentication → Users
   - Does the user exist in auth.users?
   - Is email_confirmed_at set?
   - Copy the user's UUID

3. Supabase Dashboard → Table Editor → users
   - Does the user exist with the same UUID?
   - Does the email match auth.users exactly?
   - Is the role set correctly (admin/client)?

4. Supabase Dashboard → SQL Editor
   - Run: SELECT * FROM auth.users WHERE email = 'user@email.com';
   - Run: SELECT * FROM users WHERE email = 'user@email.com';
   - Verify UUIDs and emails match

5. Check RLS Policies
   - Supabase Dashboard → Authentication → Policies
   - Ensure no circular dependencies
   - Test policies with sample queries

6. Network Tab in Browser DevTools
   - Look for failed requests to .supabase.co
   - Check response bodies for error details
   - Verify 200 status codes for successful auth

================================================================================
END OF DOCUMENT
================================================================================

